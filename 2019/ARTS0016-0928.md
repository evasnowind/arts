# ARTS0016

week 16
20190928

## Algorithm

[Leetcode 220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/)
参考了其他人的算法 [https://leetcode.com/problems/contains-duplicate-iii/discuss/61655/Java-O(N-lg-K)-solution](https://leetcode.com/problems/contains-duplicate-iii/discuss/61655/Java-O(N-lg-K)-solution)
* 算法1：双重循环，每一步都计算k次，复杂度为O(N*K),很机械
* 算法2：优化算法1，本质相同，目标都是从原有数组中不断挪动窗口，看窗口内是否有满足限制条件的数据。那么，首先假定已经选好窗口了，我们需要比较在窗口内的数字，看是否有相等的情况，而这个逻辑可以通过将窗口内元素排序、比较相邻元素来实现，因为算法1重复、无效的计算量主要是因为没有排序，排序后只要比较比当前元素小的最大元素、比当前元素大的最小元素。而排序的话，可以拿现有数据结构，下面算法则采用了TreeMap(内部利用了红黑树)，保证了高效。最后，i挪动超过k时，每挪动一次，就删除一个元素，保证窗口内元素总是k个。


## Review

[Google Guava User Guide](https://github.com/google/guava/wiki)
https://github.com/google/guava/wiki/StringsExplained 学习了google guava string相关工具接口，翻译结果参见[google guava使用教程系列（1）-String相关](https://blog.csdn.net/evasnowind/article/details/100829776)


## Tips
1. java中字符串性能优化可以利用String的intern()方法
intern()方法会优先从常量池中获取String对象的引用，如果有相关字符串常量，则不会创建新的字符串常量，直接返回该引用。

2. 在实现分布式锁时，整体上采用redis分布式锁性能要优于zookeeper、数据库实现，但可靠性、实现方式上zookeeper可靠性更高。
但实现redis分布式锁时，不推荐采用setnx或是lua脚本实现的方案，因为在redis集群情况下，可能出现redis master节点获得锁之后，没有同步给其他节点，然后master崩溃，新选出的master就还可以获得锁。此时没起到锁的作用。
redis官方给出解决方案，基于Redlock算法（链接参见：[RedLock算法介绍](https://www.jianshu.com/p/fba7dd6dcef5)），直接使用Redisson库即可。


## Share
消息队列高手课听课笔记（1）为什么需要消息队列？

**极客时间版权所有: https://time.geekbang.org/column/article/109572**

## 哪些场景适合使用消息队列？
- 异步处理
- 流量控制
- 服务解耦


### 异步处理

例如：经典面试题：如何设计一个秒杀系统？
秒杀系统需要解决的核心问题是，如何利用有限的服务器资源，尽可能多地处理短时间内的海量请求。

消息队列用于实现服务的异步处理：
- 可以更快地返回结果； 
- 减少等待，自然实现了步骤之间的并发，提升系统总体的性能。

### 流量控制

秒杀系统还需要解决：如何避免过多的请求压垮我们的秒杀系统？

一个设计健壮的程序有自我保护的能力，即可以在海量的请求下，还能在自身能力范围内尽可能多地处理请求，拒绝处理不了的请求并且保证自身运行正常。

#### 设计思路
使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的。

##### 优点
能根据下游的处理能力自动调节流量，削峰限流

##### 缺点
- 增加了系统调用链环节，导致总体的响应时延变长。
- 上下游系统都要将同步调用改为异步消息，增加了系统的复杂度。

#### 进一步优化
用消息队列实现一个令牌桶

### 服务解耦
实现系统应用之间的解耦

所有的电商都选择用消息队列来解决类似的系统耦合过于紧密的问题.

## 总结

### 适用场景
- 异步处理
- 流量控制
- 服务解耦
- 作为发布 / 订阅系统实现一个微服务级系统间的观察者模式；
- 连接流计算任务和数据；
- 用于将消息广播给大量接收者。

### 问题与局限性
- 引入消息队列带来的延迟问题
- 增加了系统的复杂度；
- 可能产生数据不一致的问题。